## 什么是惰性求值

## 一种惰性语言及其抽象语法树

constant applicative forms = 无参数sc

## 为什么是图

在惰性函数式语言中，表达式以图(graph)而非树的形式存储在内存中。

为什么要这样？

看看这个程序

```clojure
(defn square[x]  (mul x x))
(defn main[] (square (square 3)))
```

如果我们按照一般的树形表达式来求值，表达式会被规约成

```clojure
(mul (square 3) (square 3))
```

则`(square 3)`会被重复求值两遍。这绝对不是那些选择惰性求值的人想要的。

用图来表示程序是为了共享计算结果，避免重复计算，图规约的执行细节请看下文。

## 一些约定

接下来我们要讨论的是图规约如何进行。在此之前，需要预先交代一些名词与基本事实。

+ `mul`这样的东西是运行时实现的原语，称作Built-in primitive

+ 对一个表达式进行求值(当然是惰性的)并对它在图中对应的节点进行原地更新，称为规约。

+ `(square 3)`是一个可规约表达式(reducible expression，一般缩写为redex), 它可以被规约为`(mul 3 3)`.

+ `(mul 3 3)`的规约结果是表达式`9`, `9`没办法再进行规约，这种无法继续规约的基础表达式称为Normal form.

+ 一个表达式中可能存在多个子表达式(如`(mul (add 3 5) (mul 7 9))`), 在这种情况下表达式的规约顺序是很重要的 - 一些程序只在特定的规约顺序下停机。

+ 有个特殊的规约顺序永远选择最外层的redex进行规约，这叫做*normal order reduction*。下文也将统一采用这种规约顺序。

那么，可以用这样的伪代码描述图规约：

```

```

## 写个求值器

虽然有了伪代码描述的图规约过程，但是这样一个过程应该怎样写出具体的实现呢？

好消息是，它的执行过程同样是使用堆和栈的，其模型与日常写过程式语言所接触的区别也没有那么大。